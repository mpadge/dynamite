% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dynamite.R
\name{dynamite}
\alias{dynamite}
\title{Estimate a Bayesian Dynamic Multivariate Panel Model}
\usage{
dynamite(
  dformula,
  data,
  group = NULL,
  time,
  priors = NULL,
  verbose = TRUE,
  debug = NULL,
  ...
)
}
\arguments{
\item{dformula}{[\code{dynamiteformula}]\cr The model formula. See 'Details'.}

\item{data}{[\code{data.frame}, \code{tibble::tibble}, or \code{data.table::data.table}]\cr
The data frame, tibble or a data.table containing the variables in the
model. Supported column types are \code{integer}, \code{logical}, \code{double},
\code{factor}. \code{character} columns will be converted to factors.
Unused factor levels will be dropped. The \code{data} can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input \code{data} is converted to
channel specific matrix representations via \link[stats:model.matrix]{stats::model.matrix.lm}.}

\item{group}{[\code{character(1)}]\cr A column name of \code{data} that denotes the
unique groups, or \code{NULL} corresponding to a scenario without any groups.}

\item{time}{[\code{character(1)}]\cr A column name of \code{data} that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.}

\item{priors}{[\code{data.frame}]\cr An optional data frame with prior
definitions. See 'Details'.}

\item{verbose}{[\code{logical(1)}]\cr All warnings and messages are suppressed
if set to \code{FALSE}. Defaults to \code{TRUE}.}

\item{debug}{[\code{list()}]\cr A named list of form \code{name = TRUE} indicating
additional objects in the environment of the \code{dynamite} function which are
added to the return object. Additionally, values \code{no_compile = TRUE} and
\code{no_sampling = TRUE} can be used to skip the compilation of the Stan code
and sampling steps respectively. This can be useful for debugging when
combined with \code{model_code = TRUE}, which adds the Stan model code to the
return object.}

\item{...}{Additional arguments to \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling()}}.}
}
\description{
Any univariate unbounded continuous distributions supported by Stan can be
used as a prior for model parameters (the distribution is automatically
truncated to positive side for constrained parameters). In addition, any
univariate distribution bounded to positive real line can be used as a prior
for parameters constrained to be positive. See Stan function reference at
\url{https://mc-stan.org/users/documentation/} for details. For custom
priors, you should first get the default priors with \code{get_priors} function,
and then modify the \code{priors} column of the obtained data frame before
supplying it to the \code{dynamite}.
}
\details{
The default priors for regression coefficients are based on the standard
deviation of the covariates at the first non-fixed time point. In case this
is 0 or NA, it is transformed to (arbitrary) 0.5. The final prior is then
normal distribution with zero mean and two times this standard deviation.

The prior for the correlation structure of the random intercepts is defined
via the Cholesky decomposition of the correlation matrix, as
\code{lkj_corr_cholesky(1)}. See
\url{https://mc-stan.org/docs/functions-reference/
cholesky-lkj-correlation-distribution.html}
for details.

See more details in the package vignette on how to define a dynamite model.

The best-case scalability of the dynamite in terms of data size should be
approximately linear in terms of number of time points and and number of
groups, but as wall-clock time of the MCMC algorithms provided by Stan can
depend on the discrepancy of the data and the model (and the subsequent
shape of the posterior), this can vary greatly.
}
\examples{
\dontrun{
fit <- dynamite(obs(y ~ -1 + varying(~x), family = "gaussian") +
  lags(type = "varying") + splines(df = 20), gaussian_example, "id", "time",
  chains = 1, refresh = 0)

library(dplyr)
library(ggplot2)
cf <- coef(fit) \%>\%
  group_by(time, variable) \%>\%
  summarise(
    mean = mean(value),
    lwr = quantile(value, 0.025),
    upr = quantile(value, 0.975))

cf \%>\%
  ggplot(aes(time, mean)) + theme_bw() +
    geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.7) +
    geom_line() +
    facet_wrap(~ variable, scales = "free_y")
}

}
