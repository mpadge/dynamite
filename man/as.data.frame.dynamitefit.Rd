% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as_data_frame.R
\name{as.data.frame.dynamitefit}
\alias{as.data.frame.dynamitefit}
\title{Extract Samples From the dynamitefit Object as a Data Frame.}
\usage{
\method{as.data.frame}{dynamitefit}(
  x,
  row.names = NULL,
  optional = FALSE,
  responses = NULL,
  types = NULL,
  summary = TRUE,
  ...
)
}
\arguments{
\item{x}{The estimated \code{dynamite} model.}

\item{row.names}{Ignored.}

\item{optional}{Ignored.}

\item{responses}{[\code{character()}]\cr Response(s) for which the  samples
should be extracted. Possible options are \code{unique(x$priors$response)}}

\item{types}{[\code{character()}]\cr Type(s) of the parameters for which the
samples should be extracted. Possible options are \code{unique(x$priors$type)}.}

\item{summary}{[\code{logical(1)}]\cr If \code{TRUE} (default), returns posterior
mean and lower and upper limits of the 95\% posterior intervals for all
parameters. If \code{FALSE}, returns all the posterior samples instead.}

\item{...}{Ignored.}
}
\description{
You can use the arguments \code{responses} and \code{types} to extract only a subset
of the model parameters (i.e. only certain types of parameters related to a
certain response variable). The prior data frame (from \code{get_priors}) shows
potential values for these variables.
}
\note{
The spline coefficients \code{alpha} are never returned, but they can be
obtained with \code{as_draws} function among all the other parameters.
}
\examples{
results <- as.data.frame(gaussian_example_fit,
  responses = "y", types = "beta", summary = FALSE)

results |>
  dplyr::group_by(parameter) |>
  dplyr::summarise(mean = mean(value), sd = sd(value))

# basic summaries can be obtained automatically with summary = TRUE:
as.data.frame(gaussian_example_fit,
  responses = "y", types = "beta", summary = TRUE)

# Compute MCMC diagnostics via posterior package
# For this we need to first convert to wide format
# and then to draws_df object
results |>
  dplyr::select(parameter, value, .iteration, .chain) |>
  tidyr::pivot_wider(values_from = value, names_from = parameter) |>
  posterior::as_draws() |>
  posterior::summarise_draws()

# Time-varying coefficients delta
as.data.frame(gaussian_example_fit,
  responses = "y", types = "delta", summary = TRUE)

as.data.frame(gaussian_example_fit,
  responses = "y", types = "delta", summary = FALSE) |>
  dplyr::select(parameter, value, time, .iteration, .chain) |>
  tidyr::pivot_wider(
    values_from = value,
    names_from = c(parameter, time),
    names_sep = "_t=") |>
  posterior::as_draws() |>
  posterior::summarise_draws()

}
